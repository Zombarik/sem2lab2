# sem2lab2
Основи об'єктно-орієнтованого програмування
Лабораторна робота № 2
Проектування та розробка програм з використанням патернів проектування

Загальні рекомендації
Метою виконання лабораторної роботи №2 є вивчення патернів проектування, зокрема класичних патернів GoF (тобто з книги Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software). Для цього необхідно розробити відносно складний проект, використовуючи при цьому вивчені патерни. 
Цю лабораторну роботу бажано виконувати в командах з 3-4 студентів (команди можуть бути такими ж, як для проектів, або відрізнятись.) Програма має бути спроектована таким чином, щоб був поділ на відносно незалежні компоненти, і можливість різним учасникам команди працювати над різними компонентами незалежно. В репозиторії має бути видно, ким був написаний кожен фрагмент коду (варіант «один з команди комітить за всіх» не приймається).
Програма має реалізовувати графічний інтерфейс користувача (наприклад, з використанням Qt або інших фреймворків), збереження даних (наприклад, в файли чи базу даних). Можна реалізувати графічний інтерфейс у вигляді desktop, або mobile, або web застосунку. Можна також реалізувати декілька різних застосунків. Можна реалізувати клієнт-серверну архітектуру.
Необхідно підготувати документацію реалізованої програми. Зокрема, треба описати заплановану архітектуру програми (використовуючи текстові описи та/або UML діаграми). Також має бути опис того, як використовувати можливості програми – як через графічний інтерфейс, так і з коду. 
Необхідно реалізувати юніт-тести для перевірки реалізованої функціональності, алгоритмів, логіки роботи програми тощо. Юніт-тести мають більш-менш покривати реалізовану функціональність/логіку. Робити тести для інтерфейсу користувача, збереження даних в БД і т.д. не обов’язково (хоча можна, для отримання додаткових балів)
Необхідно реалізувати документацію коду (наприклад, з використанням Doxygen).
Додатково до коду необхідно описати використання патернів в документації – тобто які саме патерни використано, де в коді (точні посилання, якщо використано в декількох місцях – на усі використання), чому використано ці патерни, які проблеми вони вирішують, переваги та недоліки використання цих патернів в цих місцях тощо. Варто також проаналізувати реалізовану програму з точки зору дотримання принципів архітектури, проектування та розробки.
Зазвичай є рекомендація «не зловживати» використанням патернів, тобто не намагатись втиснути в одну програму усі патерни, які відомі розробнику. Для цієї лабораторної з демонстраційною метою можна послабити цю рекомендацію: тобто якщо в деякій ситуації можна реалізувати щось або з патернами, або без патернів – то варто про це написати в документації, і варто реалізувати варіант з патернами. (Можна також реалізувати обидва варіанти і додати механізм вибору між ними; за якісну реалізацію будуть виставлені додаткові бали).
Варто орієнтуватись на реалізацію такої кількості патернів:
Для студентів, що претендують на оцінку «відмінно» – не менше 10-12 різних патернів.
Для студентів, що претендують на оцінку «добре» – не менше 7-8 різних патернів
Для студентів, що претендують на оцінку «задовільно» – не менше 5 різних патернів
Незалежно від того, на яку оцінку претендують студенти, мають бути реалізовані патерни з усіх трьох категорій – тобто патерни створення, структурні та поведінкові. Має бути реалізовано хоча б один патерн з кожної категорії.
Варіанти програм для реалізації

В цьому документі наведено декілька можливих варіантів програм, які мають достатню складність і в яких є доцільним використання патернів. Кожна команда може обрати один з цих варіантів, і додатково уточнити що планується реалізувати в рамках підваріантів.
Студенти також можуть запропонувати власні теми для реалізації, якщо вони дозволяють реалізувати достатній обсяг функціональності та достатню кількість патернів. Запропоновану тему обов’язково треба узгодити з викладачем, що веде лабораторні заняття. Це треба зробити на початку роботи над цією лабораторною (тобто не варто відкладати це до дедлайнів здачі лабораторної).
Декілька різних команд можуть домовитись щодо можливості інтеграції розроблених ними систем в одну більш функціональну систему. Це може стосуватись як різних підваріантів одного варіанту, так і різних варіантів чи самостійно запропонованих тем (наприклад, демонстрацію роботи алгоритмів з варіанту 1 можна інтегрувати з підтримкою теоретичних та практичних завдань по алгоритмам з варіанту 2 та/або моделями обчислювальних систем з варіанту 3). При цьому варто домовитись (і задокументувати) механізми взаємодії, інтерфейси, протоколи, хто кого викликає тощо. За реалізацію такої інтеграції будуть виставлені додаткові бали. 

Варіант 1 – демонстрація роботи алгоритмів.

Розробити програму для демонстрації роботи певного класу алгоритмів. 
Можливі ідеї для компонентів:
Власне реалізації алгоритмів, структур даних.
Механізм виміру продуктивності алгоритмів (час виконання, обсяг пам’яті)
Механізм оцінки теоретичної складності алгоритмів.
Механізм підбору параметрів алгоритмів з метою підвищення продуктивності.
Візуалізація поведінки алгоритмів
Візуалізація теоретичної та практичної продуктивності алгоритмів (таблиці, графіки, …)
Документація щодо алгоритмів
Інші можливі компоненти, які мають сенс для цієї задачі
Можна розбити програму на дві частини: 1) бібліотеку з реалізацією алгоритмів чи структур даних та 2) застосунок з графічним інтерфейсом, який буде використовувати написану бібліотеку. Можна також запропонувати та реалізувати іншу схему поділу на відносно незалежні компоненти.
Реалізовані юніт-тести мають, зокрема, перевіряти коректність реалізованих алгоритмів. Зокрема, необхідно реалізувати перевірку того, що різні версії алгоритмів (тобто різні версії одного алгоритму) повертають однакові значення, якщо вони так мають працювати. Або перевірити властивості чи інваріанти структур даних чи алгоритмів (наприклад, що збалансоване дерево має приблизно однакову висоту у всіх гілках).
Ідеї щодо використання патернів:
Патерн Strategy – варто використати для реалізації алгоритмів, з можливістю заміни реалізації без зміни клієнтського коду
Патерн Template Method – варто використати для реалізації варіантів алгоритмів, коли загальна структура лишається незмінною, але якісь аспекти реалізуються по-різному в підкласах
Патерн Composite – варто використати для реалізації складних алгоритмів, які містять під-алгоритми. Можна також використати для реалізації структур даних.
Патерн Decorator – варто використати для модифікацій алгоритмів, наприклад алгоритми з додатковою перевіркою правильності параметрів. Також варто використати для вимірів часу виконання. Можна використати і для інших модифікацій.
Патерн Iterator– варто використати для обходу структур даних.
Патерн Adapter– варто використати з метою використання бібліотечних реалізацій алгоритмів (зі стандартної бібліотеки або сторонніх бібліотек)
Патерн Abstract Factory / Factory Method– варто використати для побудови стандартних реалізацій певних алгоритмів (залежно від налаштувань)
Патерн Builder– варто використати для побудови складних алгоритмів, які складаються з багатьох частин
Патерн Singleton– варто використати для підтримки класів, які мають існувати в одному екземплярі і бути доступними іншим класам (наприклад, класи для побудови алгоритмів)
Патерн Visitor– варто використати для розрахунку певних властивостей складних алгоритмів/структур даних, наприклад теоретичної складності чи обсягу пам’яті
Патерн Bridge– варто використати для створення кількох версій інтерфейсу алгоритму чи структури даних, і незалежного розвитку їх реалізацій
Патерн Command– варто використати для реалізації інтерактивного режиму роботи з алгоритмами, зокрема можливість виконувати послідовність операцій, а також режим «машини часу» з можливістю повернути назад операції
Патерн Memento– варто використати для збереження та відновлення стану алгоритмів та структур даних (можливість завершити програму посередині інтерактивного режиму і потім відновитись з тої ж позиції)
Патерн Facade– варто використати для загального інтерфейсу компонентів та взаємодії компонентів між собою.
Інші патерни як з книги GoF, так і з інших джерел – варто використовувати там, де це доцільно.
Можливі підваріанти
Варіанти цієї лабораторної будуються навколо певного класу близьких алгоритмів. Необхідно реалізувати різні алгоритми з обраного класу, починаючи від простих і до досить складних.
Можливі ідеї варіантів
Списки і схожі структури
Дерева (в тому числі балансовані дерева пошуку)
Індексовані таблиці (реалізації на основі хеш-таблиць та дерев)
Сортування
Алгоритми на графах
Комбінаторні алгоритми (зокрема, з використанням динамічного програмування, backtracking, методу гілок і границь, …)
Алгоритми дискретної оптимізації (пошук максимуму/мінімуму)
Алгоритми теорії чисел
Алгоритми лінійної алгебри (вектори, матриці, лінійні рівняння, …)
Алгоритми математичного аналізу (похідні, інтеграли, як символьні, так і чисельні алгоритми)
Чисельні методи
Алгоритми математичної статистики
В рамках однієї теми можна фокусуватись на різних аспектах алгоритмів. Можна також запропонувати свою тему, але треба погодити її з викладачем.

Варіант 2 – система для підтримки навчальних завдань.

Розробити програму для підтримки навчальних завдань з різних дисциплін, зокрема створення завдань, збір та перевірка рішень. 
Можливі ідеї для компонентів:
Створення завдань різних видів (тестові, написання коду, відповіді у вільному форматі тощо).
Генерація унікальних завдань та комбінацій завдань на основі певних шаблонів, правил та алгоритмів. Можлива підтримка інтерактивної генерації завдань – система пропонує викладачу певні «заготовки», в які викладач вносить зміни.
Механізм надсилання індивідуальних завдань окремим студентам.
Механізм збору та збереження рішень від окремих студентів.
Механізм перевірки рішень студентів, з можливістю коментувати рішення, виділяти помилки тощо.
Механізм підрахунку балів/загального результату на основі певних правил.
Механізми часткової або повної автоматизації перевірки завдань (під час генерації завдань генеруються також правила/алгоритми перевірки, які потім автоматично застосовуються для перевірки певних аспектів реалізації. Наприклад, для тестових завдань типу вибір з багатьох варіантів це повний перелік правильних варіантів; для коду це автоматичні тести та/або правила аналізу коду на стандартні помилки; для відповідей у вільному форматі перевірка наявності у відповіді певних необхідних ключових слів, та/або створення checklist за яким викладач перевіряє потрібні аспекти вручну тощо)
Візуалізація та генерація звітів щодо результатів студентів
Механізми обговорення завдань – студенти можуть задавати питання щодо формулювання завдань, коментарів викладача, своїх оцінок тощо. Можливо спілкування як між студентом та викладачем, так і в групах студентів – наприклад, обговорення вирішених завдань.
Інтеграція із зовнішніми сервісами для тестування, надсилання завдань та рішень, обговорення тощо.
Теоретичні матеріали щодо виконання завдань.
Інші можливі компоненти, які мають сенс для цієї задачі

Ідеї щодо використання патернів:
Патерн Strategy – варто використати для реалізації алгоритмів генерації завдань, підрахунку балів, автоматизованої перевірки завдань, надсилання завдань, візуалізації тощо
Патерн Template Method – варто використати для реалізації варіантів алгоритмів, коли загальна структура лишається незмінною, але якісь аспекти реалізуються по-різному в підкласах (наприклад, для генерації завдань – окремі частини завдання, або додаткові обмеження; для підрахунку балів – врахування зв’язків між окремими завданнями)
Патерн Composite – варто використати для реалізації завдань, які складаються з різнотипних підзавдань. Також для подання відповідей студентів, які можуть складатись з багатьох різнотипних частин.
Патерн Decorator – варто використати для модифікацій завдань, наприклад додаткові умови або обмеження. Також можна використовувати для візуалізації/звітів. 
Патерн Iterator – можна використати для обходу частин завдань, або рішень, або звітів, наприклад в якомусь спеціальному порядку. Можна також обмежитись використанням ітераторів зі стандартних бібліотек.
Патерн Adapter – варто використати для інтеграції з зовнішніми сервісами, рішеннями/бібліотеками/інструментами для перевірки завдань
Патерн Abstract Factory / Factory Method – варто використати для побудови об’єктів, що описують завдання, або стратегій/алгоритмів
Патерн Builder – варто використати для побудови складних завдань, які складаються з багатьох частин
Патерн Singleton – варто використати для підтримки класів, які мають існувати в одному екземплярі і бути доступними іншим класам (наприклад, класи для побудови завдань чи стратегій, налаштувань)
Патерн Visitor – варто використати для обходу складних структур даних (наприклад, завдань, шаблонів, рішень студентів тощо) з метою перевірки, розрахунку параметрів тощо.
Патерн Bridge – можна використати для створення кількох версій інтерфейсу для завдань чи рішень, і незалежного розвитку їх реалізацій
Патерн Command – варто використати для реалізації перевірки завдань, з можливістю збереження послідовності коментарів/зауважень викладача. Також можна використати для реалізації інших частин, що мають багатофункціональний інтерфейс користувача. 
Патерн Memento – варто використати для збереження та відновлення стану під час перевірки завдань (можливість завершити програму посередині перевірки завдання і потім відновитись з тої ж позиції), аналогічно для інтерактивної генерації завдань.
Патерн Proxy – варто використати для реалізації взаємодії із зовнішніми сервісами (надсилання завдань, збір та збереження рішень, перевірка завдань, генерація звітів, обговорення).
Патерн Interpreter – варто використати для аналізу складних структур даних, наприклад рішень студентів.
Патерн Flyweight – можна використати для ефективного подання схожих фрагментів завдань (зокрема, однакових частин в різних варіантах завдань).
Патерн Facade – варто використати для загального інтерфейсу компонентів та взаємодії компонентів між собою.
Інші патерни як з книги GoF, так і з інших джерел – варто використовувати там, де це доцільно.

Можливі підваріанти
Варіанти цієї лабораторної будуються навколо певних дисциплін (наприклад, тих що вивчаються в університеті, або з якими стикались в онлайн курсах тощо), та/або певного класу завдань. Необхідно реалізувати підтримку різних завдань в рамках даної дисципліни.
Можливі ідеї варіантів:
Математичні дисципліни
Вивчення іноземних мов
Дисципліни, пов’язані з розробкою/програмуванням (мови програмування, бібліотеки/фреймворки, підходи та принципи розробки)

Варіант 3 – моделювання різноманітних природніх, технічних, соціальних явищ та систем

Розробити програму для створення та запуску моделей різноманітних явищ. Система має бути розширюваною – тобто фокус не на фіксованому наборі моделей/симуляцій, а на можливості створення та додавання нових моделей. 
Можливі ідеї для компонентів:
Каталог моделей, з можливістю пошуку та групування за різними параметрами.
Можливість запуску моделі та отриманням певних результатів моделювання
Можливість візуалізації процесу моделювання та отриманих результатів
Можливість налаштування параметрів моделі, з підтримкою різних видів параметрів та способів їх введення.
Можливість задавати типові приклади вхідних даних, наприклад для демонстрації різних аспектів моделі. Задавати такі приклади можуть як автори моделей, так і користувачі що переглядають моделі (для власного використання чи для інших користувачів).
Можливість збереження історії запусків моделей, з можливістю повторного перегляду/запуску, при цьому результат моделювання при повторному запуску має бути таким самим (тобто наприклад якщо модель використовує вхідні дані різних видів – всі їх значення мають бути збережені; якщо модель використовує випадкові числа – необхідно зберегти seed генератора псевдовипадкових чисел; якщо модель завантажує зовнішні дані – необхідно зберегти їх копію тощо)
Можливість автоматизованого підбору параметрів моделі для отримання певних результатів
Механізм додавання моделей – як обчислювачів, так і візуалізаторів (задається код, або плагіни, або щось подібне)
Механізм створення типових моделей з використанням стандартних заготовок без написання коду (наприклад, редактор для комбінування частин моделей, або для задання формул обчислень тощо)
Механізм створення метрик, що описують певні параметри в процесі виконання моделей (наприклад, кількість об’єктів певного вигляду, сумарне чи максимальне значення певних параметрів, тощо). Такі метрики можуть задаватись як авторами моделей, так і користувачами що лише переглядають моделі. 
Генерація звітів, графіків тощо на основі виконання моделей.
Документація щодо моделей.
Інші можливі компоненти, які мають сенс для цієї задачі

Можливі підваріанти
Варіанти цієї лабораторної будуються навколо певного класу модельованих систем чи явищ. Необхідно реалізувати підтримку різних моделей в рамках даної галузі.
Можливі ідеї варіантів:
Фізичні процеси та явища – механіка, термодинаміка, електромагнітні явища, оптика, атомна та ядерна фізика тощо
Хімічні процеси та явища
Біологічні процеси та явища – клітини, тканини, органи, окремі організми, групи організмів, середовища та екосистеми тощо
Технічні та технологічні системи – різноманітні пристрої, транспортні засоби, промислові процеси тощо
Обчислювальні системи – комп’ютери, мережі, сервери, кластери тощо
Соціальні системи та явища – колективи, соціальні мережі, розповсюдження ідей/мемів тощо
Економічні явища – мікро- та макро-економіка, ринки, ціни тощо
Політичні явища – державні системи, партії, вибори тощо
